= `xtr`

Also called core or root functions.

== `contains(arr: Array, value: Any): Boolean`
Returns `true` if `arr` contains the given `value`, otherwise `false`.

.Example
----
xtr.contains([1, 2, 3], 1)
----
.Result
----
true
----

== `contains(obj: Object, value: Any): Boolean`
Returns `true` if `obj` contains the given `value`, otherwise `false`.

.Example
----
xtr.contains({ scala: '3.1.3' }, 'scala')
----
.Result
----
true
----

== `contains(str1: String, str2: String): Boolean`
Returns `true` if `str1` contains `str2`, otherwise `false`.

.Example
----
xtr.contains('Lorem ipsum', 'Lorem')
----
.Result
----
true
----

== `endsWith(str1: String, str2: String): String`
Returns `true` if `str1` ends with `str2`, otherwise `false`.

.Example
----
xtr.endsWith('Lorem ipsum', 'ipsum')
----
.Result
----
true
----

== `entriesOf(obj: Object[A]): Array[Object[String|A]]`
Returns an `Array[Object[String|A]]` with one `Object[String|A]` for every entry in `obj`. The result has the form of `[{ key: String, value: A }]`.

.Example
----
xtr.entriesOf({ scala: '3.1.3', java: '19' })
----
.Result
----
[
  {
    key: 'scala',
    value: '3.1.3'
  },
  {
    key: 'java',
    value: '19'
  }
]
----

== `filter(arr: Array[A], predicate Func[(A) => Boolean]): Array[A]`
Returns a new `Array[A]` containing the elements of `arr` that satisfy the given `predicate`, which must accept an `A` value to test.

.Example
----
xtr.filter([1, 2, 3, 4], function(item) item < 3)
----
.Result
----
[1, 2]
----

== `filter(arr: Array[A], predicate Func[(A, Number) => Boolean]): Array[A]`
Returns a new `Array[A]` containing the elements of `arr` that satisfy the given `predicate`, which must accept an `A` value and its `Number` index to test.

.Example
----
xtr.filter([1, 2, 3, 4], function(item, idx) idx > 2)
----
.Result
----
[4]
----

== `filterNotEq(arr: Array[A], value: B): Array[A]`
Returns a new `Array[A]` containing the elements of `arr` that are not equal to the given `value`.

.Example
----
xtr.filterNotEq([1, 2, 3, 4, 3, 4], 3)
----
.Result
----
[1, 2, 4, 4]
----

== `filterNotIn(arr: Array[A], arr2: Array[B]): Array[A]`
Returns a new `Array[A]` containing the elements of `arr1` that are not in the given `arr2`.

.Example
----
xtr.filterNotIn([1, 2, 3, 4, 3, 4], [3, 4])
----
.Result
----
[1, 2]
----

== `filterObject(obj: Object[A], predicate: Func[(A) => Boolean]): Object[A]`
Returns a new `Object[A]` containing the entries of `obj` that satisfy the given `predicate`, which must accept an `A` value to test.

.Example
----
local languages = {
    scala: { version: '3.1.3', isJvm: true },
    java: { version: '19', isJvm: true },
    python: { version: '3.10.4', isJvm: false }
};

xtr.filterObject(languages, function(lang) lang.isJvm)
----
.Result
----
{
    scala: { version: '3.1.3', isJvm: true },
    java: { version: '19', isJvm: true }
}
----

== `filterObject(obj: Object[A], predicate: Func[(A, String) => Boolean]): Object[A]`
Returns a new `Object[A]` containing the entries of `obj` that satisfy the given `predicate`, which must accept an `A` value and its corresponding `String` key to test.

.Example
----
local languages = {
    scala: { version: '3.1.3', isJvm: true },
    java: { version: '19', isJvm: true },
    python: { version: '3.10.4', isJvm: false }
};

xtr.filterObject(languages, function(lang, name) !lang.isJvm || name == 'scala')
----
.Result
----
{
    scala: { version: '3.1.3', isJvm: true },
    python: { version: '3.10.4', isJvm: false }
}
----

== `filterObject(obj: Object[A], predicate: Func[(A, String, Number) => Boolean]): Object[A]`
Returns a new `Object[A]` containing the entries of `obj` that satisfy the given `predicate`, which must accept an `A` value and its corresponding `String` key and `Number` index to test.

.Example
----
local languages = {
    scala: { version: '3.1.3', isJvm: true },
    java: { version: '19', isJvm: true },
    python: { version: '3.10.4', isJvm: false }
};

xtr.filterObject(languages, function(lang, name, idx) idx == 0 || name == 'python')
----
.Result
----
{
    scala: { version: '3.1.3', isJvm: true},
    python: { version: '3.10.4', isJvm: false}
}
----

== `flatMap(arr: Array[A], function: Func[(A) => Array[B]]): Array[B]`
Returns a new `Array[B]` containing the elements of every `Array[B]` obtained by applying the given `function` to all elements in `arr`. `function` must accept an `A` value.

.Example
----
xtr.flatMap([1, 3, 5], function(item) [item, item * item])
----
.Result
----
[1, 1, 3, 9, 5, 25]
----

== `flatMap(arr: Array[A], function: Func[(A, Number) => Array[B]]): Array[B]`
Returns a new `Array[B]` containing the elements of every `Array[B]` obtained by applying the given `function` to all elements in `arr`. `function` must accept an `A` value and its `Number` index.

.Example
----
xtr.flatMap([1, 3, 5], function(item, idx) [item, item * idx])
----
.Result
----
[1, 0, 3, 3, 5, 10]
----

== `flatMapObject(obj: Object[A], function: Func[(A) => Object[B]]): Object[B]`
Returns a new `Object[B]` containing the entries of every `Object[B]` obtained by applying the given `function` to all entries in `obj`. `function` must accept an `A` value.

.Example
----
local candidateReqs = {
    req1: { skillsType: 'dev', required: ['java'], preferred: ['unit-testing'] },
    req2: { skillsType: 'ops', required: ['containers'], preferred: ['kubernetes'] }
};
local reqsWeight(req) = {
    [req.required[0]]: 5,
    [req.preferred[0]]: 2,
    [if req.skillsType == 'dev' then 'github']: 4,
    [if req.skillsType == 'ops' then 'jenkins']: 4
};

xtr.flatMapObject(candidateReqs, reqsWeight)
----
.Result
----
{
    java: 5,
    'unit-testing': 2,
    github: 4,
    containers: 5,
    kubernetes: 2,
    jenkins: 4
}
----

== `flatMapObject(obj: Object[A], function: Func[(A, String) => Object[B]]): Object[B]`
Returns a new `Object[B]` containing the entries of every `Object[B]` obtained by applying the given `function` to all entries in `obj`. `function` must accept an `A` value and its corresponding `String` key.

.Example
----
local candidateReqs = {
    dev: { required: ['java'], preferred: ['unit-testing'] },
    ops: { required: ['containers'], preferred: ['kubernetes'] }
};
local reqsWeight(req, type) = {
    [req.required[0]]: 5,
    [req.preferred[0]]: 2,
    [if type == 'dev' then 'github']: 4,
    [if type == 'ops' then 'jenkins']: 4
};

xtr.flatMapObject(candidateReqs, reqsWeight)
----
.Result
----
{
    java: 5,
    'unit-testing': 2,
    github: 4,
    containers: 5,
    kubernetes: 2,
    jenkins: 4
}
----

== `flatMapObject(obj: Object[A], function: Func[(A, String, Number) => Object[B]]): Object[B]`
Returns a new `Object[B]` containing the entries of every `Object[B]` obtained by applying the given `function` to all entries in `obj`. `function` must accept an `A` value and its corresponding `String` key and `Number` index.

.Example
----
local candidateReqs = {
    dev: { required: ['java'], preferred: ['unit-testing'] },
    ops: { required: ['containers'], preferred: ['kubernetes'] }
};
local reqsWeight(req, type, idx) = {
    [req.required[0]]: 5,
    [req.preferred[0]]: if idx == 0 then 3 else 1,
    [if type == 'dev' then 'github']: if idx == 0 then 4 else 2,
    [if type == 'ops' then 'jenkins']: if idx == 0 then 4 else 2
};

xtr.flatMapObject(candidateReqs, reqsWeight)
----
.Result
----
{
    java: 5,
    'unit-testing': 3,
    github: 4,
    containers: 5,
    kubernetes: 1,
    jenkins: 2
}
----

== `flatten(arr: Array[Array[A]]): Array[A]`
Returns a new `Array[A]` containing the elements of every `Array[A]` in `arr`.

.Example
----
xtr.flatten([[1, 2], [3]])
----
.Result
----
[1, 2, 3]
----

== `foldLeft(arr: Array[A], initValue: Any, function: Func[(A, Any) => Any]): Any`
From left to right in `arr`, applies the given `function` to the first element along with `initValue`, then applies it to every subsequent element along with the result of the previous invocation. `function` must accept an `A` value and `Any` value, which is `initValue` for the first invocation, and the result of the previous one for all others.

Returns the `Any` result of the final `function` invocation.

> Note:
fold functions usually mutate the "accumulator" value on each invocation, thus "folding" the array into a single value.

.Example
----
xtr.foldLeft([1, 2, 3], 0, function(item, acc) item + acc)
----
.Result
----
6
----

== `foldRight(arr: Array[A], initValue: Any, Func[(A, Any) => Any]): Any`
From right to left in `arr`, applies the given `function` to the first element along with `initValue`, then applies it to every subsequent element along with the result of the previous invocation. `function` must accept an `A` value and `Any` value, which is `initValue` for the first invocation, and the result of the previous one for all others.

Returns the `Any` result of the final `function` invocation.

> Note:
fold functions usually mutate the "accumulator" value on each invocation, thus "folding" the array into a single value.

.Example
----
xtr.foldRight(['Lorem', 'ipsum', 'dolor'], '', function(item, acc) acc + ' ' + item)
----
.Result
----
' dolor ipsum Lorem'
----

== `groupBy(arr: Array[A], Func[(A) => String]): Object[Array[A]]`
Returns an `Object[Array[A]]` where the keys are the results of applying the given `function` to all elements in `arr`, and their corresponding values are the `arr` elements for which the `function` invocation resulted in such key. `function` must accept an `A` value.

.Example
----
local languages = [
    { name: 'scala', version: '3.1.3', isJvm: true },
    { name: 'java', version: '19', isJvm: true },
    { name: 'python', version: '3.10.4', isJvm: false }
];

xtr.groupBy(languages, function(lang) if lang.isJvm then 'jvmLangs' else 'others')
----
.Result
----
{
    jvmLangs: [
        { name: 'scala', version: '3.1.3', isJvm: true },
        { name: 'java', version: '19', isJvm: true }
    ],
    others: [{ name: 'python', version: '3.10.4', isJvm: false }]
}
----

== `groupBy(arr: Array[A], Func[(A, Number) => String]): Object[Array[A]]`
Returns an `Object[Array[A]]` where the keys are the results of applying the given `function` to all elements in `arr`, and their corresponding values are the `arr` elements for which the `function` invocation resulted in such key. `function` must accept an `A` value and its `Number` index.

.Example
----
local languages = [
    { name: 'scala', version: '3.1.3', isJvm: true },
    { name: 'java', version: '19', isJvm: true },
    { name: 'python', version: '3.10.4', isJvm: false }
];
local langFunc(lang, idx) = if idx == 0 then 'preferred'
    else if lang.isJvm then 'jvmLangs'
    else 'others';

xtr.groupBy(languages, langFunc)
----
.Result
----
{
    preferred: [{ name: 'scala', version: '3.1.3', isJvm: true }],
    jvmLangs: [{ name: 'java', version: '19', isJvm: true }],
    others: [{ name: 'python', version: '3.10.4', isJvm: false }]
}
----

== `groupBy(obj: Object[A], Func[(A) => String]): Object[Object[A]]`
Returns an `Object[Object[A]]` where the keys are the results of applying the given `function` to all elements in `arr`, and their corresponding values are the `arr` elements for which the `function` invocation resulted in such key. `function` must accept an `A` value.

.Example
----
local languages = {
    scala: { version: '3.1.3', isJvm: true, project: 'scala-lang.org' },
    java: { version: '19', isJvm: true, project: 'jdk.java.net' },
    python: { version: '3.10.4', isJvm: false, project: 'python.org' }
};

xtr.groupBy(languages, function(lang) if lang.isJvm then 'jvmLangs' else 'others')
----
.Result
----
{
    jvmLangs: {
        scala: { version: '3.1.3', isJvm: true, project: 'scala-lang.org' },
        java: { version: '19', isJvm: true, project: 'jdk.java.net' }
    },
    others: { python: { version: '3.10.4', isJvm: false, project: 'python.org' }}
}
----

== `groupBy(obj: Object[A], Func[(A, String) => String]): Object[Object[A]]`
Returns an `Object[Object[A]]` where the keys are the results of applying the given `function` to all elements in `arr`, and their corresponding values are the `arr` elements for which the `function` invocation resulted in such key.`function` must accept an `A` value and its corresponding `String` key.

.Example
----
local languages = {
    scala: { version: '3.1.3', isJvm: true, project: 'scala-lang.org' },
    java: { version: '19', isJvm: true, project: 'jdk.java.net' },
    python: { version: '3.10.4', isJvm: false, project: 'python.org' }
};
local langFunc(lang, name) = if name == 'scala' then 'preferred'
    else if lang.isJvm then 'jvmLangs'
    else 'others';

xtr.groupBy(languages, langFunc)
----
.Result
----
{
    preferred: { scala: { version: '3.1.3', isJvm: true, project: 'scala-lang.org' }},
    jvmLangs: { java: { version: '19', isJvm: true, project: 'jdk.java.net' }},
    others: { python: { version: '3.10.4', isJvm: false, project: 'python.org' }}
}
----

== `indicesOf(arr: Array, value: Any): Array[Number]`
Returns an `Array[Number]` with the indices of the elements in `arr` that equal `value`.

.Example
----
xtr.indicesOf([1, 7, 3, 4, 7], 7)
----
.Result
----
[1, 4]
----

== `indicesOf(str1: String, str2: String): Array[Number]`
Returns an `Array[Number]` with the indices of the substrings in `str1` that equal `str2`.

.Example
----
xtr.indicesOf('lorem ipsum dolor', 'lo')
----
.Result
----
[0, 14]
----

== `isArray(value: Any): Boolean`
Returns `true` if `value` is an `Array`, otherwise `false`.

.Example
----
xtr.isArray([1, 2])
----
.Result
----
true
----

== `isBlank(str: String): Boolean`
Returns `true` if `str` is empty or contains whitespace characters only, otherwise `false`.

.Example
----
xtr.isBlank('   ')
----
.Result
----
true
----

== `isBoolean(value: Any): Boolean`
Returns `true` if `value` is a `Boolean`, otherwise `false`.

.Example
----
xtr.isBoolean(false)
----
.Result
----
true
----

== `isDecimal(num: Number): Boolean`
Returns `true` if `num` is a decimal, otherwise `false`.

.Example
----
xtr.isDecimal(2.5)
----
.Result
----
true
----

== `isEmpty(arr: Array): Boolean`
Returns `true` if `arr` is empty, otherwise `false`.

.Example
----
xtr.isEmpty([])
----
.Result
----
true
----

== `isEmpty(obj: Object): Boolean`
Returns `true` if `obj` is empty, otherwise `false`.

.Example
----
xtr.isEmpty({})
----
.Result
----
true
----

== `isEmpty(str: String): Boolean`
Returns `true` if `str` is empty, otherwise `false`.

.Example
----
xtr.isEmpty('')
----
.Result
----
true
----

== `isEven(num: Number): Boolean`
Returns `true` if `num` is even, otherwise `false`.

.Example
----
xtr.isEven(2)
----
.Result
----
true
----

== `isFunction(value: Any): Boolean`
Returns `true` if `value` is a `Function`, otherwise `false`.

.Example
----
local increment(item) = item + 1;

xtr.isFunction(increment)
----
.Result
----
true
----

== `isInteger(num: Number): Boolean`
Returns `true` if `num` is an integer, otherwise `false`.

.Example
----
xtr.isInteger(2)
----
.Result
----
true
----

== `isNumber(value: Any): Boolean`
Returns `true` if `value` is a `Number`, otherwise `false`.

.Example
----
xtr.isNumber(2)
----
.Result
----
true
----

== `isObject(value: Any): Boolean`
Returns `true` if `value` is an `Object`, otherwise `false`.

.Example
----
xtr.isObject({})
----
.Result
----
true
----

== `isOdd(num: Number): Boolean`
Returns `true` if `num` is odd, otherwise `false`.

.Example
----
xtr.isOdd(1)
----
.Result
----
true
----

== `isString(value: Any): Boolean`
Returns `true` if `value` is a `String`, otherwise `false`.

.Example
----
xtr.isString('Lorem')
----
.Result
----
true
----

== `join(arr: Array[Number], separator: String): String`
Returns a new `String` composed of all the elements in `arr` separated by the `separator`.

.Example
----
xtr.join([0, 1, 1, 2, 3, 5, 8], ', ')
----
.Result
----
'0, 1, 1, 2, 3, 5, 8'
----

== `join(arr: Array[String], String): String`
Returns a new `String` composed of all the elements in `arr` separated by the `separator`.

.Example
----
xtr.join(['hello', 'world', '!'], ' ')
----
.Result
----
'hello world !'
----

== `keysOf(obj: Object): Array[String]`
Returns an `Array[String]` containing all the keys in `obj`.

.Example
----
xtr.keysOf({ scala: '3.1.3', java: '19' })
----
.Result
----
['scala', 'java']
----

== `lower(str: String): String`
Returns the lowercase representation of `str`.

.Example
----
xtr.lower('Hello World!')
----
.Result
----
'hello world!'
----

== `map(arr: Array[A], function: Func[(A) => B]): Array[B]`
Returns a new `Array[B]` with the results of applying `function` to all elements in `arr`. `function` must accept an `A`.

.Example
----
xtr.map([1, 2, 3, 4], function(item) item * item)
----
.Result
----
[1, 4, 9, 16]
----

== `map(arr: Array[A], function: Func[(A, Number) => B]): Array[B]`
Returns a new `Array[B]` with the results of applying `function` to all elements in `arr`. `function` must accept an `A` and its `Number` index.

.Example
----
xtr.map([1, 2, 3, 4], function(item, idx) item * idx)
----
.Result
----
[0, 2, 6, 12]
----

== `mapEntries(obj: Object[A], function: Func[(Object[A]) => B]): Array[B]`
Returns an `Array[B]` with the results of applying `function` to all entries in `obj`. `function` must accept an `A`.

.Example
----
local languages = {
    scala: { version: '3.1.3', isJvm: true, project: 'scala-lang.org' },
    java: { version: '19', isJvm: true, project: 'jdk.java.net' },
    python: { version: '3.10.4', isJvm: false, project: 'python.org' }
};

xtr.mapEntries(languages, function(lang) lang.project)
----
.Result
----
['scala-lang.org', 'jdk.java.net', 'python.org']
----

== `mapEntries(obj: Object[A], function: Func[(Object[A], String) => B]): Array[B]`
Returns an `Array[B]` with the results of applying `function` to all entries in `obj`. `function` must accept an `A` and its corresponding `String` key.

.Example
----
local languages = {
    scala: { version: '3.1.3', isJvm: true, project: 'scala-lang.org' },
    java: { version: '19', isJvm: true, project: 'jdk.java.net' }
};

xtr.mapEntries(languages, function(lang, name) {
    name: name,
    version: lang.version
})
----
.Result
----
[
    { name: 'scala', version: '3.1.3' },
    { name: 'java', version: '19' }
]
----

== `mapEntries(obj: Object[A], function: Func[(Object[A], String, Number) => B]): Array[B]`
Returns an `Array[B]` with the results of applying `function` to all entries in `obj`. `function` must accept an `A` and its corresponding `String` key and `Number` index.

.Example
----
local languages = {
    scala: { version: '3.1.3', isJvm: true, project: 'scala-lang.org' },
    java: { version: '19', isJvm: true, project: 'jdk.java.net' }
};
local langFunc(lang, name, idx) = {
    name: name,
    [if idx == 0 then 'preferred']: true
};

xtr.mapEntries(languages, langFunc)
----
.Result
----
[{ name: 'scala', preferred: true }, { name: 'java' }]
----

== `mapObject(obj: Object[A], function: Func[(A) => Object[B]]): Object[B]`
Returns a new Object[B] containing the entry of every Object[B] obtained by applying the given `function` to all entries in obj. `function` must accept an `A` value.

== `mapObject(obj: Object[A], function: Func[(A, String) => Object[B]]): Object[B]`
Returns a new Object[B] containing the entry of every Object[B] obtained by applying the given `function` to all entries in obj. `function` must accept an `A` value and its corresponding `String` key.

== `mapObject(obj: Object[A], function: Func[(A, String, Number) => Object[B]]): Object[B]`
Returns a new Object[B] containing the entry of every Object[B] obtained by applying the given `function` to all entries in obj. `function` must accept an `A` value and its corresponding `String` key and `Number` index.

== `max(arr: Array[Boolean]): Boolean`
Returns the max `Boolean` in `arr`, with `true` being "bigger" than `false`.

.Example
----
xtr.max([false, false, true])
----
.Result
----
true
----

== `max(arr: Array[Number]): Number`
Returns the max `Number` in `arr`.

.Example
----
xtr.max([0, 8, 2, 100])
----
.Result
----
100
----

== `max(arr: Array[String]): String`
Returns the max `String` in `arr`.

.Example
----
xtr.max(['Lorem', 'zzz', 'ipsum', 'dolor'])
----
.Result
----
'zzz'
----

== `maxBy(arr: Array[A], function: Func[(A) => Boolean]): Array[A]`
Returns the max `A` by comparing the values returned by `function`, which must accept an `A`.

.Example
----
local languages = [
    { name: 'java', version: '19', isPreferred: false },
    { name: 'python', version: '3.1.14', isPreferred: false }
    { name: 'scala', version: '3.1.3', isPreferred: true },
];

xtr.maxBy(languages, function(lang) lang.isPreferred)
----
.Result
----
{ name: 'scala', version: '3.1.3', isPreferred: true }
----

== `maxBy(arr: Array[A], function: Func[(A) => Number]): Array[A]`
Returns the max `A` by comparing the values returned by `function`, which must accept an `A`.

.Example
----
local languages = [
    { name: 'java', version: '19', weight: 2 },
    { name: 'python', version: '3.1.14', weight: 2 }
    { name: 'scala', version: '3.1.3', weight: 4 },
];

xtr.maxBy(languages, function(lang) lang.weight)
----
.Result
----
{ name: 'scala', version: '3.1.3', weight: 4 }
----

== `maxBy(arr: Array[A], function: Func[(A) => String]): Array[A]`
Returns the max `A` by comparing the values returned by `function`, which must accept an `A`.

.Example
----
local languages = [
    { name: 'java', version: '19', code: 'B' },
    { name: 'python', version: '3.1.14', code: 'B' },
    { name: 'scala', version: '3.1.3', code: 'S' }
];

xtr.maxBy(languages, function(lang) lang.code)
----
.Result
----
{ name: 'scala', version: '3.1.3', code: 'S' }
----

== `min(arr: Array[Boolean]): Boolean`
Returns the min `Boolean` in `arr`, with `false` being "smaller" than `true`.

.Example
----
xtr.min([false, false, true])
----
.Result
----
false
----

== `min(arr: Array[Number]): Number`
Returns the min `Number` in `arr`.

.Example
----
xtr.min([0, 8, 2, 100])
----
.Result
----
0
----

== `min(arr: Array[String]): String`
Returns the min `String` in `arr`.

.Example
----
xtr.min(['Lorem', 'AAA', 'ipsum', 'dolor'])
----
.Result
----
'AAA'
----

== `minBy(arr: Array[A], comparator: Func[(A) => Boolean]): Array[A]`
Returns the min `A` by comparing the values returned by `function`, which must accept an `A`.

.Example
----
local languages = [
    { name: 'java', version: '19', isPreferred: false },
    { name: 'python', version: '3.1.14', isPreferred: false },
    { name: 'scala', version: '3.1.3', isPreferred: true }
];

xtr.minBy(languages, function(lang) lang.isPreferred)
----
.Result
----
{ name: 'java', version: '19', isPreferred: false }
----

== `minBy(arr: Array[A], comparator: Func[(A) => Number]): Array[A]`
Returns the min `A` by comparing the values returned by `function`, which must accept an `A`.

.Example
----
local languages = [
    { name: 'java', version: '19', weight: 2 },
    { name: 'python', version: '3.1.14', weight: 2 },
    { name: 'scala', version: '3.1.3', weight: 4 }
];

xtr.minBy(languages, function(lang) lang.weight)
----
.Result
----
{ name: 'java', version: '19', weight: 2 }
----

== `minBy(arr: Array[A], comparator: Func[(A) => String]): Array[A]`
Returns the min `A` by comparing the values returned by `function`, which must accept an `A`.

.Example
----
local languages = [
    { name: 'java', version: '19', code: 'B' },
    { name: 'python', version: '3.1.14', code: 'B' },
    { name: 'scala', version: '3.1.3', code: 'S' }
];

xtr.minBy(languages, function(lang) lang.code)
----
.Result
----
{ name: 'java', version: '19', code: 'B' }
----

== `numOf(str: String): Number`
Returns the `Number` representation of the given `str`.

.Example
----
numOf('123.45')
----
Result
----
123.45
----

== `sortBy(arr: Array[A], Func[(A) => Boolean]): Array[A]`
Returns a new `Array[A]` with the conents of `arr` sorted by comparing the values returned by `function`, which must accept and `A`.

.Example
----
local languages = [
    { name: 'java', version: '19', isPreferred: false },
    { name: 'scala', version: '3.1.3', isPreferred: true },
    { name: 'python', version: '3.1.14', isPreferred: false }
];

xtr.minBy(languages, function(lang) lang.isPreferred)
----
.Result
----
[
    { name: 'java', version: '19', isPreferred: false },
    { name: 'python', version: '3.1.14', isPreferred: false },
    { name: 'scala', version: '3.1.3', isPreferred: true }
]
----

== `sortBy(arr: Array[A], Func[(A) => Number]): Array[A]`
Returns a new `Array[A]` with the conents of `arr` sorted by comparing the values returned by `function`, which must accept and `A`.

.Example
----
local languages = [
    { name: 'java', version: '19', weight: 3 },
    { name: 'scala', version: '3.1.3', weight: 4 },
    { name: 'python', version: '3.1.14', weight: 2 }
];

xtr.sortBy(languages, function(lang) lang.weight)
----
.Result
----
[
    { name: 'python', version: '3.1.14', weight: 2 },
    { name: 'java', version: '19', weight: 3 },
    { name: 'scala', version: '3.1.3', weight: 4 }
]
----

== `sortBy(arr: Array[A], Func[(A) => String]): Array[A]`
Returns a new `Array[A]` with the conents of `arr` sorted by comparing the values returned by `function`, which must accept and `A`.

.Example
----
local languages = [
    { name: 'java', version: '19', code: 'B' },
    { name: 'scala', version: '3.1.3', code: 'S' },
    { name: 'python', version: '3.1.14', code: 'B' }
];

xtr.sortBy(languages, function(lang) lang.code)
----
.Result
----
[
    { name: 'java', version: '19', code: 'B' },
    { name: 'python', version: '3.1.14', code: 'B' },
    { name: 'scala', version: '3.1.3', code: 'S' }
]
----

== `range(first: Number, last: Number): Array[Number]`
Returns an `Array[Number]` containing numbers from `first` to `last`.

.Example
----
xtr.range(1, 5)
----
.Result
----
[1, 2, 3, 4, 5]
----

== `read(data: String, mediaType: String): Any`
Parses the `data` as the given `mediaType`.

.Example
----
xtr.read('<hello>world!</hello>', 'application/xml')
----
.Result
----
{
  hello: { '$': 'world!' }
}
----

== `read(data: String, mediaType: String, params: Object): Any`
Parses the `data` as the given `mediaType` with `params` options.

.Example
----
xtr.read('<hello>world!</hello>', 'application/xml', { textvaluekey: '_txt' })
----
.Result
----
{
  hello: { _txt: 'world!' }
}
----

== `readUrl(url: String, mediaType: String): Any`
Retrieves the data at `url` and parses it as the given `mediaType`. Supported schemes/protocols are `http`, `https`, `classpath`, and `file`.

Asumming `example.com` returns `<hello>world!</hello>`:

.Example
----
xtr.readUrl('example.com/data', 'application/xml')
----
.Result
----
{
  hello: { '$': 'world!' }
}
----

== `readUrl(url: String, mediaType: String, params: Object): Any`
Retrieves the data at `url` and parses it as the given `mediaType` with `params` options. Supported schemes/protocols are `http`, `https`, `classpath`, and `file`.

Asumming `example.com` returns `<hello>world!</hello>`:

.Example
----
xtr.readUrl('example.com', 'application/xml', { textvaluekey: '_txt' })
----
.Result
----
{
  hello: { _txt: 'world!' }
}
----

== `rmKey(obj: Object[A], key: String): Object[A]`
Returns a new `Object[A]` containing the entries of `obj` minus the entry for the given `key`.

.Example
----
xtr.rmKey({ scala: '3.1.3', java: '19' }, 'java')
----
.Result
----
{ scala: '3.1.3' }
----

== `rmKeyIn(obj: Object[A], arr: Array[String]): Object[A]`
Returns a new `Object[A]` containing the entries of `obj` minus the entries whose key is not in the given `arr`.

.Example
----
xtr.rmKeyIn({ scala: '3.1.3', java: '19' }, ['java', 'scala'])
----
.Result
----
{}
----

== `replace(str1: String, str2: String, str3: String): String`
Returns a new `String` with the contents of `str1`, with occurrences of `str2` replaced by `str3`.

.Example
----
xtr.replace('hello, world!', 'world', 'everyone')
----
.Result
----
'hello, everyone!'
----

== `reverse(arr: Array): Array`
Returns a new `Array` with the elements of `arr` in reversed order.

.Example
----
xtr.reverse([1, 2, 3])
----
.Result
----
[3, 2, 1]
----

== `reverse(obj: Object): Object`
Returns a new `Object` with the entries of `obj` in reversed order.

.Example
----
xtr.reverse({ key1: 'value1', key2: 'value2' })
----
.Result
----
{ key2: 'value2', key1: 'value1' }
----

== `reverse(str: String): String`
Returns a new `String` with the characters of `str` in reversed order.

.Example
----
xtr.reverse('rolod muspi meroL')
----
.Result
----
'Lorem ipsum dolor'
----

== `sizeOf(arr: Array): Number`
Returns the size of `arr`.

.Example
----
xtr.sizeOf([1, 2, 3])
----
.Result
----
3
----

== `sizeOf(func: Function): Number`
Returns the number of `func` parameters.

.Example
----
local add(item, item2) = item + item2;

xtr.sizeOf(add)
----
.Result
----
2
----

== `sizeOf(obj: Object): Number`
Returns the number of entries in `obj`.

.Example
----
xtr.sizeOf({ key: 'value' })
----
.Result
----
1
----

== `sizeOf(str: String): Number`
Returns the number of characters in `str`.

.Example
----
xtr.sizeOf('hello, world!')
----
.Result
----
13
----

== `split(str1: String, str2: String): Array[String]`
Returns an `Array[String]` containing the chunks of `str1` split by the contents of `str2`.

.Example
----
xtr.split('hello, world!', 'o')
----
.Result
----
['hell', ', w', 'rld!']
----

== `startsWith(str1: String, str2: String): Boolean`
Returns `true` if `str1` starts with `str2`.

.Example
----
xtr.startsWith('hello, world!', 'hello')
----
.Result
----
true
----

== `toString(value: String|Number|Boolean|Null): String`
Returns the `String` representation of `value`.

.Example
----
{
    bool: xtr.toString(true),
    num: xtr.toString(365),
    nil: xtr.toString(null)
}
----
.Result
----
{
    bool: 'true',
    num: '365',
    nil: 'null'
}
----

== `trim(str: String): String`
Returns a new `String` with the contents of `str` removed of leading and trailing whitespaces.

.Example
----
xtr.trim('  hello, world!   ')
----
.Result
----
'hello, world!'
----

== `typeOf(value: Any): String`
Returns the `String` name of the type of `value`.

.Example
----
local func(it) = it;

{
    bool: xtr.typeOf(true),
    num: xtr.typeOf(365),
    nil: xtr.typeOf(null),
    arr: xtr.typeOf([]),
    obj: xtr.typeOf({}),
    func: xtr.typeOf(func)
}
----
.Result
----
{
    bool: 'boolean',
    num: 'number',
    nil: 'null',
    arr: 'array',
    obj: 'object',
    func: 'function'
}
----

== `upper(String): String`
Returns the uppercase representation of `str`.

.Example
----
xtr.upper('Hello World!')
----
.Result
----
'HELLO WORLD!'
----

== `uuid(): String`
Generates a new random UUID v4 `String`.

.Example
----
xtr.uuid()
----
.Result
----
'8eae62af-d2dc-4759-8316-ce6eeca0b61c'
----

== `valuesOf(obj: Object[A]): Array[A]`
Returns an `Array[String]` containing all the values in `obj`.

.Example
----
xtr.valuesOf({ scala: '3.1.3', java: '19' })
----
.Result
----
['3.1.3', '19']
----

== `write(data: Any, mediaType: String): String`
Writes the `data` as the given `mediaType`

.Example
----
xtr.write({ hello: 'world', arr: [], nil: null }, 'application/json')
----
.Result
----
'{"hello":"world","arr":[],"nil":null}'
----

== `write(data: Any, mediaType: String, params: Object[): String`
Writes the `data` as the given `mediaType` with `params` options.

.Example
----
xtr.write({ hello: 'world', arr: [] }, 'application/json', { indent: true })
----
.Result
----
'{\n    "hello": "world",\n    "arr": [\n        \n    ]\n}'
----

// todo
// == `indexOf(arr: Array[A], value: A): Number
// == `indexOf(str1: String, str2: String): Number
// == `lastIndexOf(arr: Array[A], value: A): Number
// == `lastIndexOf(str1: Array[A], str2: String): Number
