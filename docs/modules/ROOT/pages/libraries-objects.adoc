= `tro.objects`

== `all(obj, Object[A], predicate: Func[(A, String) => Boolean]): Boolean`
Returns `true` if all entries in `obj` satisfy the given `predicate`, otherwise `false`. `predicate` must accept an `A` and its corresponding `String` key.

.Example
----
local languages = {
    scala: { version: '3.1.3', isJvm: true },
    java: { version: '19', isJvm: true },
    python: { version: '3.10.4', isJvm: false }
};

tro.objects.all(languages, function(lang, name) lang.isJvm)
----
.Result
----
false
----

== `any(obj, Object[A], predicate: Func[(A, String) => Boolean]): Boolean`
Returns `true` if any entry in `obj` satisfies the given `predicate`, otherwise `false`. `predicate` must accept an `A` and its corresponding `String` key.

.Example
----
local languages = {
    scala: { version: '3.1.3', isJvm: true },
    java: { version: '19', isJvm: true },
    python: { version: '3.10.4', isJvm: false }
};

tro.objects.any(languages, function(lang, name) lang.isJvm)
----
.Result
----
true
----

== `distinctBy(obj: Object[A], Func[(A) => B]): Object[A]`
Returns a new `Object` with the distinct entries in `obj` using the given `identity` function for comparison. `identity` must accept an `A`.

.Example
----
local languages = {
    first: { name: 'scala', version: '3.1.3', isJvm: true },
    second: { name: 'java', version: '19', isJvm: true },
    third: { name: 'java', version: '18', isJvm: true }
};

tro.objects.distinctBy(languages, function(lang) lang.name)
----
.Result
----
{
    first: { name: 'scala', version: '3.1.3', isJvm: true },
    second: { name: 'java', version: '19', isJvm: true }
}
----

== `distinctBy(obj: Object[A], Func[(A, String) => B]): Object[A]`
Returns a new `Object` with the distinct entries in `obj` using the given `identity` function for comparison. `identity` must accept an `A` and its corresponding `String` key.

.Example
----
local languages = {
    first: { name: 'scala', version: '3.1.3', isJvm: true },
    second: { name: 'java', version: '19', isJvm: true },
    third: { name: 'java', version: '18', isJvm: true }
};

tro.objects.distinctBy(languages, function(lang, ordinal)
    if (lang.name == 'java') then lang.version
    else ordinal
)
----
.Result
----
{
    first: { name: 'scala', version: '3.1.3', isJvm: true },
    second: { name: 'java', version: '19', isJvm: true },
    third: { name: 'java', version: '18', isJvm: true }
}
----

== `innerJoin(arrL: Array[Object[A]], arrR: Array[Object[B]], identity: Func[(Object[A]) => String|Number|Boolean], identityR: Func[(Object[B]) => String|Number|Boolean)]): Array[Object[C]]`
Returns a new `Array` with all the objects that exist in both `arrL` _and_ `arrR`, using the given `identity` functions to compute equality, and joined using a shallow merge.

.Example
----
local customers = [
    { id: 2, email: 'joe@example.com', joined: '2021-07-30' },
    { id: 77, email: 'jane@example.com', joined: '2019-07-30' },
    { id: 17, email: 'john@example.com', joined: '2002-07-03' }
];

local orders = [
    { orderId: 10308, customerId: 2, date: '2022-07-30' },
    { orderId: 10309, customerId: 2, date: '2022-07-30' },
    { orderId: 10310, customerId: 77, date: '2022-07-03' },
    { orderId: 10311, customerId: 93, date: '2021-05-03' }
];

tro.objects.innerJoin(customers, orders
    function(cust) cust.id, function(order) order.customerId)
----
.Result
----
[
    { id: 2, email: 'joe@example.com', joined: '2021-07-30',
        orderId: 10308, customerId: 2, date: '2022-07-30' },
    { id: 2, email: 'joe@example.com', joined: '2021-07-30',
        orderId: 10309, customerId: 2, date: '2022-07-30' },
    { id: 77, email: 'jane@example.com', joined: '2019-07-30',
        orderId: 10310, customerId: 77, date: '2022-07-03' }
]
----

== `innerJoin(arrL: Array[Object[A]], arrR: Array[Object[B]], identity: Func[(Object[A]) => String|Number|Boolean], identityR: Func[(Object[B]) => String|Number|Boolean), join: Func[(Object[A], Object[B]) => Object[C]]): Array[Object[C]]`
Returns a new `Array` with all the objects that exist in both `arrL` _and_ `arrR`, using the given `identity` functions to compute equality, and joined using a shallow merge.

.Example
----
local customers = [
    { id: 2, email: 'joe@example.com', joined: '2021-07-30' },
    { id: 77, email: 'jane@example.com', joined: '2019-07-30' },
    { id: 17, email: 'john@example.com', joined: '2002-07-03' }
];

local orders = [
    { orderId: 10308, customerId: 2, date: '2022-07-30' },
    { orderId: 10309, customerId: 2, date: '2022-07-30' },
    { orderId: 10310, customerId: 77, date: '2022-07-03' },
    { orderId: 10311, customerId: 93, date: '2021-05-03' }
];

tro.objects.innerJoin(customers, orders
    function(cust) cust.id, function(order) order.customerId,
    function(cust, order) { id: cust.id, oId: order.id })
----
.Result
----
[
    { id: 2, orderId: 10308 },
    { id: 2, orderId: 10309 },
    { id: 77, orderId: 10310 }
]
----

== `leftJoin(arrL: Array[Object[A]], arrR: Array[Object[B]], identity: Func[(Object[A]) => String|Number|Boolean], identityR: Func[(Object[B]) => String|Number|Boolean)]): Array[Object[C]]`
Returns a new `Array` with all the objects that exist in `arrL`, joined with a shallow merge with those that also exist in `arrR`, using the given `identity` functions to compute equality.

.Example
----
local customers = [
    { id: 2, email: 'joe@example.com', joined: '2021-07-30' },
    { id: 77, email: 'jane@example.com', joined: '2019-07-30' },
    { id: 17, email: 'john@example.com', joined: '2002-07-03' }
];

local orders = [
    { orderId: 10308, customerId: 2, date: '2022-07-30' },
    { orderId: 10309, customerId: 2, date: '2022-07-30' },
    { orderId: 10310, customerId: 77, date: '2022-07-03' },
    { orderId: 10311, customerId: 93, date: '2021-05-03' }
];

tro.objects.leftJoin(customers, orders
    function(cust) cust.id, function(order) order.customerId)
----
.Result
----
[
    { id: 2, email: 'joe@example.com', joined: '2021-07-30',
        orderId: 10308, customerId: 2, date: '2022-07-30' },
    { id: 2, email: 'joe@example.com', joined: '2021-07-30',
        orderId: 10309, customerId: 2, date: '2022-07-30' },
    { id: 77, email: 'jane@example.com', joined: '2019-07-30'
        orderId: 10310, customerId: 77, date: '2022-07-03' },
    { id: 17, email: 'john@example.com', joined: '2002-07-03' }
]
----

== `leftJoin(arrL: Array[Object[A]], arrR: Array[Object[B]], identity: Func[(Object[A]) => String|Number|Boolean], identityR: Func[(Object[B]) => String|Number|Boolean), join: Func[(Object[A], Object[B]) => Object[C]]): Array[Object[C]]`
Returns a new `Array` with all the objects that exist in `arrL`, joined with the given `join` function with those that also exist in `arrR`, using the given `identity` functions to compute equality.

.Example
----
local customers = [
    { id: 2, email: 'joe@example.com', joined: '2021-07-30' },
    { id: 77, email: 'jane@example.com', joined: '2019-07-30' },
    { id: 17, email: 'john@example.com', joined: '2002-07-03' }
];

local orders = [
    { orderId: 10308, customerId: 2, date: '2022-07-30' },
    { orderId: 10309, customerId: 2, date: '2022-07-30' },
    { orderId: 10310, customerId: 77, date: '2022-07-03' },
    { orderId: 10311, customerId: 93, date: '2021-05-03' }
];

tro.objects.leftJoin(customers, orders
    function(cust) cust.id, function(order) order.customerId,
    function(cust, order) { id: cust.id, oId: order?.id })
----
.Result
----
[
    { id: 2, oId: 10308 },
    { id: 2, oId: 10309 },
    { id: 77, oId: 10310 },
    { id: 17, oId: null }
]
----

== `fullJoin(arrL: Array[Object[A]], arrR: Array[Object[B]], identity: Func[(Object[A]) => String|Number|Boolean], identityR: Func[(Object[B]) => String|Number|Boolean) => Object[C]]): Array[Object[C]]`
Returns a new `Array` with all the objects that exist in `arrL` or in `arrR`, joining those that exist in both with a shallow merge, and using the given `identity` functions to compute equality.

.Example
----
local customers = [
    { id: 2, email: 'joe@example.com', joined: '2021-07-30' },
    { id: 77, email: 'jane@example.com', joined: '2019-07-30' },
    { id: 17, email: 'john@example.com', joined: '2002-07-03' }
];

local orders = [
    { orderId: 10308, customerId: 2, date: '2022-07-30' },
    { orderId: 10309, customerId: 2, date: '2022-07-30' },
    { orderId: 10310, customerId: 77, date: '2022-07-03' },
    { orderId: 10311, customerId: 93, date: '2021-05-03' }
];

tro.objects.fullJoin(customers, orders
    function(cust) cust.id, function(order) order.customerId)
----
.Result
----
[
    { id: 2, email: 'joe@example.com', joined: '2021-07-30',
        orderId: 10308, customerId: 2, date: '2022-07-30' },
    { id: 2, email: 'joe@example.com', joined: '2021-07-30',
        orderId: 10309, customerId: 2, date: '2022-07-30' },
    { id: 77, email: 'jane@example.com', joined: '2019-07-30'
        orderId: 10310, customerId: 77, date: '2022-07-03' },
    { id: 17, email: 'john@example.com', joined: '2002-07-03' },
    { orderId: 10311, customerId: 93, date: '2021-05-03' }
]
----

== `fullJoin(arrL: Array[Object[A]], arrR: Array[Object[B]], identity: Func[(Object[A]) => String|Number|Boolean], identityR: Func[(Object[B]) => String|Number|Boolean) => Object[C]], join: Func[(Object[A], Object[B]) => Object[C]]): Array[Object[C]]`
Returns a new `Array` with all the objects that exist in `arrL` or in `arrR`, joining those that exist in both with the given `join` function, and using the given `identity` functions to compute equality.

.Example
----
local customers = [
    { id: 2, email: 'joe@example.com', joined: '2021-07-30' },
    { id: 77, email: 'jane@example.com', joined: '2019-07-30' },
    { id: 17, email: 'john@example.com', joined: '2002-07-03' }
];

local orders = [
    { orderId: 10308, customerId: 2, date: '2022-07-30' },
    { orderId: 10309, customerId: 2, date: '2022-07-30' },
    { orderId: 10310, customerId: 77, date: '2022-07-03' },
    { orderId: 10311, customerId: 93, date: '2021-05-03' }
];

tro.objects.fullJoin(customers, orders
    function(cust) cust.id, function(order) order.customerId,
    function(cust, order) { id: cust.?id, oId: order?.id })
----
.Result
----
[
    { id: 2, oId: 10308 },
    { id: 2, oId: 10309 },
    { id: 77, oId: 10310 },
    { id: 17, oId: null },
    { id: null, oId: 10311 }
]
----
